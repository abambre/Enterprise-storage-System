 created.

The raw markdown file/string is incorporated in the `Document` class. The basic pre processing and parsing happens in this class. For every new string/File for converting Markdown to HTML a new instance of this class is created.

We defined a `Proc`(block, anonymous method) which was used to render individual element.

The main data structure you parsing is `Stack` class. It is used to push/pop the child elements. The nested Stack/Array creates the parsing tree for HTML file.

`MarkParser` is main module/interface for usage. It has a public method `convert` which is exposed for the outside world.

    `MarkParser.convert("# Markdown String")`

#### Functional JavaScript Based Mark Parser

The functional JavaScript design utilizes what is called Higher Order Functions, this means that functions can be passed around as arguments to other functions and one function can return another function. The advantage that we derive out of using Higher Order Functions is that we avoid repeating loops that are very common in imperative programming and moreover it makes code more readable. The higher order function that we have "forEach" takes in two arguments: a list and an action. The input Markdown file is divided into a list of sentences (lines) and this list is passed as one of the argument. The action is a ParseIt function that further parses this each of the list element and assigns it an appropriate HTML tag using a JSON dictionary.

JSON dictionary is a JSON Key Value Pair that corresponds a markdown tag to its equivalent HTML Start Tag and HTML end Tag. This helps in identifying correct tag for each and every markdown list argument that is provided as input.

We also utilized Map & Reduce algorithms to build our product. Our design allows us to perform a particular action over each item of a list, and combine the results (HTML converted output) to a base value and finally return the result as single results.

## Testing

### Unit Tests
Unit test is when each component/ function is test individual. If it asserts the expected output the test is considered to pass.
Unit testing was done for core classes and methods. It tested if the methods delivered the expected output individually. It consisted of the basic cycle of setup, test and teardown.
For the Ruby(OO) track, we used RSpec, a popular TDD based testing framework.
To test the individual Elements like "h1, ol, etc", we created markdown string containing just those elements and tested them individually.
For the Javascript track(functional), we used Jasmine as the testing library.
Along with commandline, it has a HTML page where teh results can be published.

We also built a 'wysiwyg' editor for the javascript, it rendered the HTML interactively. This made testing each element(tag) manually easier.

### Integration Tests
Integration tests are which makes sure that major portions of the software work together. It tests the combination of all modules together.
We created multiple sample.md files and its equivalent HTML files. It consisted of all the tags which we had implemented.
If the the HTML generated by the software and the expected HTML has 0 diff, then the test is considered to be passed.

### Style Check
We followed the style guide defined by the community. We used `rubocop` and `JSlint` to detect style guide violations for respective languages.

### Automated test
Travis CI service was used to test the project hosted on Github.It is continuous integration server and runs the test suites for every commit on master. The test suites contain unit test cases for testing individual tags and integration tests for testing the entire markdown file containing combination of markdown tags. This made sure that master branch always had green tests.

## Methods

In this section we discuss out development methodology in detail. Below we have discussed the Software Engineering workflow that we felt would be best for our team. We have also provided details about the methods and tools that helped us in communication, collaboration, and code review.

### Development Process:
Th